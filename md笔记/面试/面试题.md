

[toc]

# HTML

## Html 规范中为什么要求引用资源不加协议头`http`或者`https`？

```
如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似
 的警告信息，同时还可以节省5字节的数据量。
```









# CSS

## CSS盒模型

盒子模型分为：

- IE盒子模型：`width`只包括了content
- ***W3C标准盒子模型***  `width`包括了content.**padding +border** 注意是没有`margin`的

应尽量声明DOCTYPE类型来使用W3C模型



## rem和em

rem是根据根的font-size变化，而em是根据父级的font-size变化





## 回流和重绘（reflow & repaint）

### 

<h4>浏览器的渲染机制</h1>



* 浏览器采用流式布局模型
* 浏览器会把HTML解析成DOM，CSS解析成CSSOM  ===》 渲染树（render tree）
* 通常情况下一次遍历就完成了浏览器渲染。**但是table布局不一样可能会发生多次计算。不推荐table布局**



一句话总结：

<p style="font-size:30px;color:red">回流是重绘的子集</p>

<h4>重绘</h4>

页面中的元素样式的改变并不影响它在文档中的位置时（color , background-color , visibility）



<h4>回流(Reflow)</h4>

当Render Tree中元素的尺寸，结构或者某些属性发生改变时。浏览器重新渲染文档的过程叫做回流、包括以下：

* 页面首次渲染
* 浏览器窗口大小改变
* 元素的尺寸、位置、内容发生改变
* 添加或者删除**<font color="red">可见DOM</font>**
* 激活css伪类
* 调用一些方法或者属性：获取宽高度，滚动距离等







![image-20210611085415740](https://tva1.sinaimg.cn/large/008i3skNgy1gre1ky9x2fj308l04eq2u.jpg)



<h4>如何避免？</h4>

<h5>CSS</h5>

* 避免使用table布局
* **将动画效果加载position为 absolute 或者 fixed的元素上**
* 避免使用css表达式

<h5>Js</h5>

* 避免频繁操作DOM 或者style  。
* 也可以将元素设置`display:none` 操作结束再改回去





## 选择器和权重

1. !important;
2. 行内
3. #id  100
4. 类选择器/属性选择器/伪类选择器  10
   1. `.class`
   2. `input[type="text"]`
   3. `a:hover`
5. 标签选择器和伪元素选择器 1
   1. `div, h1`
   2. `::before`







## BFC

### 常见的定位方案

1. 普通流
   1. BFC:块级格式化上下文。看做是一个隔离容器，内部不会影响到外部。
2. 浮动(float)
3. 绝对定位



### BFC触发条件

1. body根元素
2. 浮动元素:`float:none以外的值,left`触发浮动定位
3. `overflow:不为visibile，如：hidden,auto,scroll`
4. 绝对定位：`postion:absolute/fixed`
5. `display:flex/inline-block`



### BFC特性

1. 同一个BFC中margin折叠====>设置为不同的BFC
2. 清除浮动塌陷。
3. 左边固定宽度，右边自适应的两列自适应布局。





## link 和 @import

*@import：*

1. 只能导入样式表
2. 引入的css文件在页面加载完毕后加载
3. DOM不可控



*link*：

1. 除了样式表还能加载RSS、rel
2. 引入的css文件被同时加载
3. DOM可控





## 两行省略

```css
  overflow: hidden;
  text-overflow: ellipsis; //省略
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2; //块容器中的内容限制为指定行数
  -webkit-box-orient: vertical;
```

![image-20201009084639912](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjisjl91ehj312q0bcq5l.jpg)







## 圣杯布局 和双飞翼布局

> 中间栏目要放在文档流前面优先渲染。

传统方式：

```html
<div class="content">
  <div class="main">main</div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
```

思路：

1. 都`float:left`
2. `main 宽度设置100%`
3. 左边：`margin-left:-100%`   ,右边：`margin-left:-自身宽度`
4. `content设置padding-left  padding-right 值 为左右留出空间`
5. 左右设置`reletive。  left 设置 left为 -left宽度   右边同样、`

```html
<body>
<div id="hd">header</div>
<div id="bd">
  <div id="middle">middle</div>
  <div id="left">left</div>
  <div id="right">right</div>
</div>
<div id="footer">footer</div>
</body>

<style>
#hd{
    height:50px;
    background: #666;
    text-align: center;
}
#bd{
    /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/
    padding:0 200px 0 180px;
    height:100px;
}
#middle{
    float:left;
    width:100%;/*左栏上去到第一行*/
    height:100px;
    background:blue;
}
#left{
    float:left;
    width:180px;
    height:100px;
    margin-left:-100%;
    background:#0c9;
    /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/
    position:relative;
    left:-180px;
}
#right{
    float:left;
    width:200px;
    height:100px;
    margin-left:-200px;
    background:#0c9;
    /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/
    position:relative;
    right:-200px;
}
#footer{
    height:50px;
    background: #666;
    text-align: center;
}
</style>
```





#### `flex 实现`

` flex : flex-grow ,flex-shrink flex-basis 的简写`

```html
  <style>
    * {
      box-sizing: border-box;
    }
    .content {
      display:flex;
    }

    .main {
      flex:1;
      height:100px;
      border:1px solid red;
    }
    .left {
      flex:0 0 100px;
      order:-1; /*在左边*/
      height:100px;
      border:1px solid #000;
    }
    .right {
      flex:0 0 100px;
      height:100px;
      border:1px solid #000;
    }



  </style>
</head>
<body>
<div class="content">
  <div class="main">main</div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>

```

#  JS



## 1. 函数题

### reduce

```js
arr.reduce((accumulator,currentVal,index,array)=>{},initialValue)
```

* reducer函数
  * accumulator: 上一次调用的累计返回值或者initialValue
  * currentVal: 数组中正在处理的元素。
    * index 可选
    * array  可选

####  reduce的常见用法

```js
let items =[10,120,140];
const sum =items.reduce((total,num)=>total+num,10)
console.log(sum);
```

**对象数组求和**

```js
const result = [
    { subject: 'math', score: 88 },
    { subject: 'chinese', score: 95 },
    { subject: 'english', score: 80 }
];

const ans =result.reduce((acc,currentVal)=>{
    return  acc =acc+currentVal.score;
},0)
console.log(ans);

```

**数组最大值**

```js
const a = [23,123,342,12];
// acc 存储当前的最大值
const max =a.reduce((acc,currentVal)=>{
   return  acc>currentVal?acc:currentVal
})
console.log(max);

```



**统计字符串中字母出现的次数**

```js
const str = 'sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha';
// 统计str中各个字符出现的次数.
// 假设acc 是一个{key:value}对象，所有出现的key都存放在acc中
const ans = str.split('').reduce((acc,currentVal)=>{
    if (acc[currentVal]){
        acc[currentVal]++;
    }else {
        acc[currentVal] =1;
    }
    return acc;
},{})
console.log(ans);
```



**扁平二维数组**

```js
var arr = [[1, 2, 8], [3, 4, 9], [5, 6, 10]];
const ans =arr.reduce((acc,currentVal)=>{
   return  acc = [...acc,...currentVal]
},[])
console.log(ans);
```





### 节流和防抖

> 防抖(debounce):事件被触发n秒后再执行回调，如果n秒内又被触发，重新计时。

> 节流（throttle）：在规定时间内，只能触发一次函数。



> 防抖：在搜索输入框中，根据用户输入内容变化动态展示联想搜索词
>
> 节流：抢票啊、提交数据、切换、轮播和部分Animate动画中，执行完上一次操作后才能再次点击执行对应的函数。鼠标滚动。

[跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

[节流](https://github.com/mqyqingfeng/Blog/issues/26)

[防抖和节流](https://segmentfault.com/a/1190000018428170)

简易版：返回一个函数，函数中先清除定时器，再设置一个定时器。

```js
function debounce(func,wait){
  let timeout;
  return function(){
    clearTimeout(timeout);
    timeout = setTimeout(func,wait)
  }
}
container.onmousemove = debounce(getUserAction, 1000);
```

节流简易版：触发时就取当前时间戳。判断是否大于时间周期，然后更新previous。

```js
function throttle(func, wait) {
    var context, args;
    var previous = 0;
    return function() {
        var now = +new Date();
        context = this;
        args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```



### 函数柯里化

```js
    function add(a, b,c) {
        return a + b+ c;
    }
   const curry =function (fn,args) {
       const len =fn.length;
       args =args || [];
       return function () {
           //保存已经进入的参数
           let _args =args.slice(0);
           for (let i = 0; i <arguments.length ; i++) {
               let _arg =arguments[0];
               _args.push(_arg);
           }
           if (_args.length<len){
               // 传入目前为止的数组，积累数量。
               return curry.call(this,fn,_args);
           }else {
               //对于原函数直接传入已经准备好的数组
               return fn.apply(this,fn,_args);
           }
       }
   }
   const fn =curry(add);
   console.log(fn(1)(2)(3));
```



###  深浅拷贝

> 深浅拷贝都是对于引用类型而言。
>
> 浅拷贝指对于引用类型只复制了一层。
>
> 深拷贝复制到最后一层

#### 数据类型

![image-20210704095555580](https://tva1.sinaimg.cn/large/008i3skNly1gs4om7bsiqj31hs0sq0wo.jpg)



#### 浅拷贝

数组的浅拷贝：

```js
let new_arr =arr.concat();
let new_arr1=arr.slice();
```



```js
let shallowCopy=function(obj){
  if(typeof obj !== 'object') return;
  let newObj =obj instanceof Array ? []:{};
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      newObj[key] = obj[key];
    }
  }
  return newObj;
}
```



#### 一层深拷贝，多层浅拷贝

##### Json实现的深拷贝：`Json.parse(Json.stringify(obj))`

其原理就是将obj转为string类型的基本数据类型，赋值后再恢复为obj。



缺陷：对于如下对象：

```js
let obj = {
    nul: null,
    und: undefined,   //被忽略
    sym: Symbol('sym'), //被忽略
    str: 'str',
    bol: true,
    num: 45,
    arr: [1, 4],
    reg: /[0-9]/,
    dat: new Date(),
    fun: function() {},   //被忽略
}
```



##### `Object.assign()/...展开运算符`: 一层内的深拷贝，多层浅拷贝

将源对象的可枚举属性复制到目标上。

```js
let obj={
  a:{
    a1:'a1'
  },
  b:'b'
}
let ass =Object.assign({},obj);
let ass1={...obj};
ass.a.a1='aaa';
console.log(obj);
```



#### 深拷贝

```js
let deepCopy=function(obj){
  if(typeof obj !== 'object') return;
  let newObj =obj instanceof Array ? []:{};
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      //在拷贝时判断一下是否是对象，如果是对象递归深拷贝。
      newObj[key] = typeof obj[key] ==='object'?deepCopy(obj[key]):obj[key];
    }
  }
  return newObj;
}
```



### 手写flatten

1. 将最终结果作为参数传递进去，

```js

// 递归传递一个最终结果进去
function baseFlatten(array, depth, isStrict=false,predicate=function (o) {
    return Array.isArray(o)
},result=[]) {
    var index = -1,
        length = array.length;
    while (++index < length) {
        let   value =array[index];
        if (depth>0){
            if (predicate(value)){
                baseFlatten(value,depth-1,isStrict,predicate,result)
            }else {
                result.push(value)
            }
        }else if (!isStrict){
          result.push(value)
        }
    }
    // 返回的是最终的flatten结果
    return result;
}
console.log(baseFlatten([1, [2, [3, [4]], 5]],3))

```



2. 将每层结果返回

```js
// 逐层返回flatten之后的结果。
function deepFlatten(arr) {
    let ans=[];
    for (let i = 0; i <arr.length ; i++) {
        if (Array.isArray(arr[i])){
          ans=ans.concat(deepFlatten(arr[i]))
        }else {
          ans.push(arr[i])
        }
    }
    console.log(ans);
    return ans;
}

function deepFlattenWithDepth(arr,depth) {
        let ans =[];
    for (let i = 0; i <arr.length ; i++) {
        if (depth>0){
            if (Array.isArray(arr[i])){
                ans =ans.concat(deepFlattenWithDepth(arr[i],depth-1))
            }else {
                ans.push(arr[i])
            }
        }else {
           ans.push(arr[i])
        }
    }
    // 返回的是每一层的flatten结果
    return ans;
}


console.log(deepFlattenWithDepth([1, [2, [3, [4]], 5]],2))
```



### 手写bind

> bind：创建一个新函数，新函数被调用时将 bind的第一个参数作为运行时的this，后续参数作为运行时的参数传入。

```js
    const foo ={
        value:1
    }
    function bar() {
        console.log(this.value);
    }
  const foo1 =  bar.bind(foo);
    foo1();
```



简单版

```js
   Function.prototype.mybind =function (newThis,...args) {
        const self=this;
       return function () {
           self.apply(newThis,args)
       }
    }
```





### 手写apply

> 使用一个指定this 和若干参数的情况下调用某个方法。 **参数为数组**

```js
const  foo ={
   value:1
}
function bar(){
  console.log(this.value)
}

```



使用`bar.apply(foo)`其实 **可以考虑将bar添加为foo的一个属性，然后再删除**

```js
const foo ={
        value:1
    }
function bar(name,age) {
        console.log(name);
        console.log(age);
        console.log(this.value)
    }
Function.prototype.myApply =function (newObj,arg) {
        newObj.fn =this;
        newObj.fn(...arg);
        delete newObj.fn;
}
    bar.myApply(foo,['aaa',3])
```













### 其他

#### `['1','2','3'].map(parseInt)`

`parseInt(string[,radix])`

* `string :` 要被解析的字符串，如果不是`toString()转换为字符串`	
* `radix : string的基数  2-36`
* 返回整数 或 `NaN`



```js
['1','2','3'].map(parseInt)

['1','2','3'].map((item,index)=>{
  return parseInt(item,index)
})

parseInt('1', 0) // 1
parseInt('2', 1) // NaN
parseInt('3', 2) // NaN, 3 不是二进制
```



## 2. 事件冒泡、捕获、事件代理/委托、阻止默认事件

[选中复选框是点击复选框的默认行为以及输入框禁止输入大写字母](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault)





## 3. this指向问题

> this的指向是在函数执行时确定的。

具体分为以下几种情况：

1. 作为对象方法调用：`obj.a()`

   this指向obj

2. 普通函数调用：`a()`

   this指向window，严格模式下undefined

3. 构造函数调用：`let b = new A()`

   通常情况下，构造函数里的this指向返回的这个对象，但是如果构造器**显示**地返回**了一个**object类型的对象，则this指向这个返回的object对象.

4. `bind,call,apply`

5. 超时和箭头函数，箭头函数没有this，取决于上层作用域中的this。

6. 当函数被用作事件处理函数时，它的 `this` 指向触发事件的元素。


```js
window.a = 2;
var obj = {
    a:1,
    getA:function(){
        console.log(this.a);
    }
}
obj.getA();       //输出1，作为对象的方法调用，this指向当前对象
var x = obj.getA;
x();   //输出2，作为普通函数调用，this全部指向window对象。
```



构造函数

```js
var Myclass = function(){
    this.name = 'beidan';
}
var obj = new Myclass();
console.log(obj.name);//beidan

var Myclass = function(){
    this.name = 'beidan';
    return{         //显示的返回一个对象，注意！既要是显示，即有return，也要是对象{}
        name:'test'
    }
}
var obj = new Myclass();
console.log(obj.name);//test
```





bind、call、apply都是用来改变函数体中this指向。

bind不会立即调用而是返回一个新函数，称为绑定函数。

`call(thisArg,arg1,arg2)`N个参数。

`apply(thisArg,[arg1,arg2])`,apply两个参数，this和数组。

call、apply用处：

1. 修正this指向：

```js
document.getElementById('div1').onclick = function(){
    console.log(this.id);   //div1
    var func = function(){
        console.log(this.id);
    }
    func();   //通过普通函数调用，this指向window，输出undefined
  	func.call(this)；//使用call，使func函数内部的this指向当前的函数对象，输出div1
}
```



2. 借用其他对象的方法

```js
function fruits() {}
fruits.prototype = {
    color: "red",
    say: function() {
        console.log("My color is "+ this.color);
    }
}
var apple = new fruits;
apple.say();    //My color is red

banana={color:'yellow'};
apple.say.call(banana); 
```

```js
var numbers = [5, 458 , 120 , -215 ];
var maxInNumbers = Math.max.apply(Math, numbers),   //458
maxNumbers = Math.max.call(Math,5, 458 , 120 , -215, 666); //666
```



**超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象**，**在严格模式下是undefined**

```js
const  zhangsan ={
    name:'zhangsan',
    sayHi(){
        console.log(this)  //zhangsan
    },
    wait(){
      setTimeout(function () {
          console.log(this)   //全局  是setTimeout触发了
      })
    },
    wait1() {
        setTimeout(()=>{
            console.log(this)   //zhangsan ,箭头
        })
    }
}

zhangsan.wait1();


```

setTimeout中的i仍然是add作用域中的，只不过this指向了window。

```
i =1;
function add() {
    const i= 3;
    setTimeout(function () {
        console.log(i) // 3
        console.log(this.i); //1
    },1000)
}
add();
```



## 3. 如何创建一个对象？

> Es6中类 =es5构造函数+原型继承

创建对象的方式：

### 3.1 工厂模式

缺点：没有解决对象标识问题。（对象是什么类型的呢？）

```js
function createPerson(name,age,job){
    const o = new Object(); 
    o.name =name;
    o.age = age;
    o.job = job;
    o.sayName =function (){
        console.log(this.name)
    }
    return o
}

const person = createPerson('liuj',28, 'fe');
person.sayName();
```

### 3.2 构造函数

和工厂函数类似。

1. 没有创建新对象。`new Object()`
2. 工厂模式中赋值给o的，赋值给了this
3. 没有return 新对象

```js
function Person(name,age,job){  // 函数声明形式， 函数表达式也可。
    this.name =name;
    this.age = age;
    this.job = job;
    this.sayName =function (){
        console.log(this.name)
    }
}
const person = new Person('liuj',28, 'fe');
```

#### 3.2.1 new的时候做了什么？

1. 创建一个空对象`{}` ,就是工厂模式的第一步
2. **设置空对象的constructor为new的对象。**
3. **this指向1中创建的对象。**
4. 如果该函数没有返回对象，返回this，工厂模式的最后一步。

```js
let o =new Object();
o._proto_=A.prototype;
A.call(o);
```



#### 3.2.2 构造函数和普通函数有什么区别？

**构造函数和普通函数的唯一区别就是：是否采用new调用。**

#### 3.2.3 构造函数的缺点

**构造函数的缺点在于：构造函数的方法在每个实例都创建了一遍**

```js
function Person(name,age,job){
    this.name =name;
    this.age = age;
    this.job = job;
    this.sayName =function () {
        console.log(this.name)
    }
}

const person1 =new Person('liu','28','fe')
const person2 =new Person('liu','28','fe')

console.log(person1.age ===person2.age);//true
console.log(person1.sayName ===person2.sayName);// false
```





### 3.3 原型模式

```js
function Person() {}

Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { console.log(this.name); };

let person1 = new Person(); 
person1.sayName(); // "Nicholas"
let person2 = new Person();
person2.sayName(); // "Nicholas"
```



<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5zbzyrslqj30xw0u0qfs.jpg" alt="image-20190814172409847" style="zoom:50%;" />

有以下方法：

1. `Person.prototype.isPrototypeOf(person); // true` 判断原型是否是某实例的原型。

   1. 与`instanceOf`相同.

2. `Object.getPrototypeOf(person)== Person.prototype //true` 获取实例的原型。

   

实例上的同名属性会遮蔽原型上的该名属性。通过delete 该属性，可以解除对原型属性的遮蔽。



#### 3.3.1 判断属性归属



![image-20210108155046546](https://tva1.sinaimg.cn/large/008eGmZEgy1gmgc6xmx2bj314g0kgq4r.jpg)

包括：`Object.assign() 也是有序的`



#### 3.3.2 原型的缺点

所有实例都共享一份数据。单个实例对于数据的修改会影响所有实例。



### 继承的实现方式：

* 原型链+构造函数
* Class



### 自己实现new

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply

可以用`let obj = Object.create(func.prototype)`代替下10、12行


```js
    function Car(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    var car1 = new Car('Eagle', 'Talon TSi', 1993);
    
    function myNew(func,...args) {
      //新建对象
        let obj = {};
      // 修改__propto指向
        obj.__proto__ =func.prototype;
      
     // let obj = Object.create(func.prototype)
      // 使用obj为this，args为参数调用func。
        func.apply(obj,args)
      // 返回
        return obj;
    }
    const car2 =myNew(Car,'Eagle', 'Talon TSi', 1993);
```







## 6. 跨域

### 同源策略

**同源**：两个URL的协议（protocal）、端口（port）、主机（host）都相同称为同源。

我们可以通过`window.origin`或`location.origin`得到当前源。

**同源策略的作用：**

1. 防止CSRF（cross-site request forgery，跨站请求伪造）攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。
2. 防止利用<iframe>其他网站获取数据。



### 跨域解决方案

#### Jsonp

后端收到请求的时候，将数组放到前端准备好的函数中，调用一下。

> html中<script>、<img>获取资源是没有跨域限制,这种方式只能GET

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd3eqql86j31up0u07dw.jpg" alt="image-20210711163209866" style="zoom:100%;" />





#### CORS(cross-origin resource sharing,跨域资源共享)

服务器端实现。

##### CORS请求分类

简单请求和非简单请求。

简单请求：

1. 请求方法是以下：
   1. HEAD
   2. GET
   3. POST
2. 头信息：
   1. Accept
   2. Accept-Language
   3. Content-Language
   4. Last-Event-ID
   5. Content-Type：application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain



###### 简单请求

浏览器对于简单请求直接发出CORS请求，在http头信息中加入一个**Origin**字段。如：

`Origin: http://api.bob.com`

服务器根据origin判断是否同意。

1. 同意，返回如下

   ```js
   Access-Control-Allow-Origin: http://api.bob.com
   Access-Control-Allow-Credentials: true
   Access-Control-Expose-Headers: FooBar
   Content-Type: text/html; charset=utf-8
   ```

2. 不同意，返回正常HTTP响应。但是没有`Access-Control-Allow-Origin`字段。浏览器也就是根据该字段判断是否校验通过。

###### 非简单请求

非简单请求：比如请求方法是PUT、DELETE，Content-Type是application/json的情况。

区别：

非简单请求会在正式通信之前进行一次HTTP查询请求：预检请求（preflight），主要询问域名是否许可、可以使用哪些HTTP动词和HTTP头信息。

预检请求的请求方法：`OPTIONS`，返回码是204。之后才是200

![image-20201018101751358](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjt9rb53evj312403c3zd.jpg)







#### nginx代理

> 同源策略是浏览器的策略，通过nginx获取转发请求绕过同源策略。

## 7. get和post的区别







##  8.js的执行机制

### 进程和线程

> **进程是资源分配的最小单位，线程是CPU调度的最小单位**



### 浏览器的进程和线程

[参考](https://juejin.im/post/6844904050543034376#heading-14)

浏览器是多进程的：

1. Browser进程
2. 第三方插件
3. GPU进程
4. 渲染进程（浏览器内核）
   1. GUI渲染线程：DOMTree、CSSTree、回流和重绘
   2. JS引擎：和GUI渲染线程互斥
   3. 事件触发线程：事件队列
   4. 定时器线程：setInterval和setTimeout等计时并不是在JS引擎中实现的。在计时完毕后加入事件触发线程中。
   5. 异步http请求

![image-20191025091717285](https://tva1.sinaimg.cn/large/006y8mN6gy1g8a6jl5aayj30nk0mr7bz.jpg)

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。



**所以 setInterval 是每隔固定时间将事件注册入Event Queue** 

> - Macro-task（宏任务task）
>   - 整体scrpit
>   - `setInterval`
>   - `setTimeout`
> - Micro-task(微任务jobs）：
>   - Promise, process.nextTick
>   - catch
>   - finally
>   - Promise.then()





**task==>jobs===>GUI渲染===>task**

所以在处理

```js
document.body.style = 'background:black';
document.body.style = 'background:red';
document.body.style = 'background:blue';
document.body.style = 'background:pink';
```

浏览器会直接渲染成pink



> > 不同类型的任务会进入对应的Event Queue，比如`setTimeout`和`setInterval`会进入相同的Event Queue。
>
> ```
>  //进来是宏任务1
>  setTimeout(function() {    //宏任务2
>      console.log('setTimeout');
>  })
>  
>  new Promise(function(resolve) { 
>      console.log('promise');
>  }).then(function() {      //then中是微任务1
>      console.log('then');
>  })
>  
>  console.log('console');
>  
>  console.log('1');
>  
>  setTimeout(function() {
>      console.log('2');
>      process.nextTick(function() {
>          console.log('3');
>      })
>      new Promise(function(resolve) {
>          console.log('4');
>          resolve();
>      }).then(function() {
>          console.log('5')
>      })
>  })
>  process.nextTick(function() {
>      console.log('6');
>  })
>  new Promise(function(resolve) {
>      console.log('7');
>      resolve();
>  }).then(function() {
>      console.log('8')
>  })
>  
>  setTimeout(function() {
>      console.log('9');
>      process.nextTick(function() {
>          console.log('10');
>      })
>      new Promise(function(resolve) {
>          console.log('11');
>          resolve();
>      }).then(function() {
>          console.log('12')
>      })
>  })
> ```





## 9. 闭包

### 什么是闭包

> 能够读取其他函数内部变量的函数

```js
function A(){
  let a =1;
  function B(){
    console.log(a);
  }
  return B();
}
A();
```



### 闭包题

[重要的问题](https://juejin.cn/post/6844903474212143117#heading-1)

```js
for(var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 3 3 3
```



如果要输出变为0 1 2

1. `let`

```js
for(let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 3 3 3
```



2. 立即执行函数

```js
for(var i = 0; i < 3; i++) {
  (function(i){
    setTimeout(function() {
      console.log(i);
    }, 1000);
  })(i)
}
```



3. 函数传参

```js
    var output = function (i) {
        setTimeout(function() {
            console.log(new Date, i);
        }, 1000);
    };

    for (var i = 0; i < 5; i++) {
        output(i);  // 这里传过去的 i 值被复制了

    }

    console.log(new Date, i);
```







### 函数柯里化

#### 暴力解法

```js
function add (a) {
	return function (b) {
		return function (c) {
		    return a + b + c;
		}
	}
}
console.log(add(1)(2)(3)); // 6
```



```js
 function add(a, b,c) {
     return a + b+ c;
 }
const curry =function (fn,args) {
    const len =fn.length;
    args =args || [];
    return function () {
        //保存已经进入的参数
        let _args =args.slice(0);
        for (let i = 0; i <arguments.length ; i++) {
            let _arg =arguments[0];
            _args.push(_arg);
        }
        if (_args.length<len){
            // 传入目前为止的数组，积累数量。
            return curry.call(this,fn,_args);
        }else {
            //对于原函数直接传入已经准备好的数组
            return fn.apply(this,fn,_args);
        }
    }
}
const fn =curry(add);
console.log( fn(1)(2)(3));
```





```js
function curry (fn, arr = []) {
    return fn.length === arr.length ? fn.apply(null, arr) : function (...args) {
        return curry (fn, arr.concat(args))
    }
}
```



```js
const curry = (fn, arr = []) => fn.length === arr.length ? fn(...arr) : (...args) => curry(fn, [...arr, ...args]);
```



## 10. 原型和原型链







## 11. promise

[手写promise](https://juejin.cn/post/6844903625769091079#heading-6)

### 手写promise加载图片

```js
function loadImg(src) {
    const p =new Promise(
        (resolve,reject)=>{
            const img =document.createElement('img');
            img.onload =()=>{
                resolve(img)
            }
            img.onerror=()=>{
                const error =new Error(`图片加载失败${src}`)
                reject(error)
            }
            img.src=src
        }
    )
    return p
}

const url =`http://img.mukewang.com/szimg/5b508e3a000166ad20000560.jpg`

loadImg(url)
    .then(img =>{
        console.log(img.width)
        return img
    })
    .then(img =>{
        console.log(img.height)
    })

```



### 红绿黄灯间隔

关键点：

1. 红灯3秒的等待用promise的pending状态+settimeout实现。
2. 等待时长结束后，用resolve()去返回下一个promise状态。

```js
 function red() {
    console.log('red');
}

function green() {
    console.log('green');
}

function yellow() {
    console.log('yellow');
}

let myStep =()=>{
    Promise.resolve().then(()=>{
        return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                red();
                resolve();
            },3000)
        })
    })
        .then(()=>{
            return new Promise((resolve, reject) => {
                setTimeout(()=>{
                    green();
                    resolve();
                },2000)
            })
        })
        .then(()=>{
         return new Promise((resolve, reject) =>{
             setTimeout(()=>{
                 yellow()
                 resolve();
             },1000)
         } )
        })
        .then(()=>{
            return new Promise((resolve, reject) =>{
               myStep();
            })
        })
}

myStep();

```



抽取共同代码：

```js
const myLighter =(cb,wait)=>{
        return new Promise((resolve, reject)=>{
            setTimeout(()=>{
                cb();
                resolve();
            },wait)
        })
}
let myStep =()=>{
    Promise.resolve().then(()=>{
        return myLighter(red,3000)
    })
        .then(()=>{
            return myLighter(green,3000)
        })
        .then(()=>{
           return  myLighter(yellow,1000)
        })
        .then(()=>{
            return myLighter(myStep,0)
        })
}
myStep();
```





## 12. 前端鉴权

1. HTTP Basic Authentication
2. session-cookie
3. Token（JWT，SSO）
4. OAuth（开放授权）

### cookie、sessionStorage、localStorage

sessionStorage中数据在同一窗口（标签页）关闭后丢失。

localStorage同源都保存。

### HTTP Basic Auth

验证流程如下：

1. 未验证客户端发送请求给服务器

   ```http
    Get /index.html HTTP/1.0 
     Host:www.google.com
   ```

2. 服务器返回客户端：401请求验证代码。 **WWW-Authenticate: Basic realm=”google.com”** 

   ```http
    HTTP/1.0 401 Unauthorised 
     Server: SokEvo/1.0 
     WWW-Authenticate: Basic realm=”google.com”    //关键
     Content-Type: text/html 
     Content-Length: xxx
   
   ```

3. 客户端收到401，弹出登录页面。用户输入用户名密码。客户端将用户名密码加密发送。**Base64不安全**

   ```http
     Get /index.html HTTP/1.0 
     Host:www.google.com 
     Authorization: Basic d2FuZzp3YW5n
   ```



### Session-cookie

1. 浏览器第一次访问服务器。服务器创建session。并生成sessionID响应给浏览器。
2. 浏览器将sessionID保存在cookie中。每次访问携带sessionID
3. 之后每次访问都携带sessionID，服务器根据sessionID判断权限。

缺点：

	1. 服务器内存消耗大
	2. CSRF攻击。



###  Token

token = uid+time+sign组成。

客户端在首次登陆以后，服务端再次接收http请求的时候，就只认token了，请求只要每次把token带上就行了，服务器端会拦截所有的请求，然后校验token的合法性，合法就放行，**不合法就返回401**（鉴权失败）。

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据



#### Token和session的区别

1. token无状态，session是一种记录服务器和客户端的会话状态机制。
2. token不需要借助cookie。cookie-session必须要通过cookie实现。而token可以再多种客户端使用且不需要一定通过cookie。





####  JWT（JSON Web Tokens）

> JWT =Header.Payload.Signature

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtbe2q828j319c0cmgqq.jpg" alt="image-20201018111424725" style="zoom:40%;" />

JWT的特点：

1. 默认不加密，但是可以加密
2. JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
3. 应使用HTTPS



### SSO（单点登录）

> **用户只需要登录一次就可以访问所有相互信任的应用系统**，SSO使用一个独立的认证中心。子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。

## 13. Vue

### Vue生命周期

| 阶段          | 介绍                                                         | 使用场景              |
| ------------- | ------------------------------------------------------------ | --------------------- |
| beforecreate  | 组件未被创建                                                 | loading事件           |
| create        | 组件创建，属性绑定，data存在，dom无、$el无                   | 结束loading、异步请求 |
| beforeMount   | 虚拟dom                                                      |                       |
| mount         | dom                                                          |                       |
| beforeUpdate  | data变化前                                                   |                       |
| update        | data变化后                                                   |                       |
| beforeDestory |                                                              |                       |
| destory       | 对data的改变不再触发周期函数、vue已经解除事件监听和dom绑定，dom结构存在 |                       |



### Vue双向绑定原理

`Object.defineProperty()`:直接在一个对象上定义新属性或者修改现有属性并返回该对象。

采用数据劫持和发布者订阅者模式的方式。用`Object.defineProperty()`来劫持对象属性的setter、getter，然后将变动传递给订阅者。

​	下面是简单的双向绑定实现：

```js
<body>
    <div id="app">
        <input type="text" id="txt">
        <p id="show"></p>
    </div>

<script>
    let obj={};
    Object.defineProperty(obj,'txt',{
        get:function () {
            return obj
        },
        set:function(newValue) {
            document.getElementById('txt').value=newValue;
            document.getElementById('show').innerHTML=newValue;
        }
    })
    document.addEventListener('keyup',function (e) {
        obj.txt=e.target.value
    })

</script>
```



### class和style的对象数组语法

class对象语法：

```js
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

data: {
  isActive: true,
  hasError: false
}

```

class数组语法：

```js
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

```

style对象语法：

```jsx
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

data: {
  activeColor: 'red',
  fontSize: 30
}

```

style数组语法：

```js
<div v-bind:style="[styleColor, styleSize]"></div>

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}

```



### 对于数组的哪些操作，Vue检测不到

1. vm.items[index]=newValue

   解决方案：`Vue.set(vm.items,index,newValue)`

2. vm.items.length=newLength

   解决方案：`vm.items.splice(newLenght)`



### 组件通信

#### 父传子

> 父组件通过:将对象传递给子组件，子组件通过props:{}来接收。

父组件

```js

<template>
    <child :msg="message"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    data () {
        return {
            message: 'father message';
        }
    }
}
</script>
```

子组件：

```js
<template>
    <div>{{msg}}</div>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    }
}
</script>

```



#### 子传父

> ```js
> (子组件)this.$emit('parentFunction',this.childmsg)
> (父组件dom)v-on:parentFunction="customParentFunction"
> (父组件JS)customParentFunction(msg){
>     //msg就是子组件传递过来的数据
> }
> ```

父组件:

```js
<template>
  <div id="app">
    <!--监听子组件触发的parentFunction事件,然后调用customParentFunction方法-->
    <child-component v-on:parentFunction = "customParentFunction"></child-component>
  </div>
</template>

<script>
  import childComponent from './components/childComponent'

  export default {
    name: 'App',
    components:{
      childComponent
    },
    methods: {
        customParentFunction(msg){
            console.log('子组件传过来的值',msg)
        }
    }
  }
</script>

```



子组件：

```js
<template>
  <div>
    <button @click="sendDataToParent">向父组件传值</button>
  </div>
</template>

<script>
  export default {
    name: 'childComponent',
    data(){
        return{
            childmsg:'我是子组件的值'
        }
    }
    methods:{
        sendDataToParent(){
            //$emit（even,value）even 是一个函数，value 是传给父组件的值
            this.$emit('parentFunction',this.childmsg)
        }
    }
  }
</script>

```







### Vue路由

**hash模式**:

1. 可以通过`window.location.hash`读取
2. hash虽然包括在url中但是不包括在http请求中，所以服务器端并不能区别hash的不同
3. 完全由前端控制路由

**history模式**

1. 采用h5中的`pushState()`、`replaceState()`对浏览器的记录栈进行修改。
2. 后端需要对前端的路由进行配合，否则会404.



####  router 和  route

$route 是路由信息对象。包括path、params、hash、query、fullPath、matched、name

$router 路由实例。包括路由的跳转方法、钩子函数。

	1.  router.beforeEach(to,from,next)
	2.  Router.push()
	3.  Router.forward

###  Vuex

Store中存放只用来读取的状态。

mutation：提交mutation来改变Store的值。

action：异步逻辑



### 指令:对普通DOM元素进行底层操作

v-for

v-if

v-bind

v-on

v-show

v-else

还可以自定义指令：如聚焦输入框：

**局部注册指令**

```js
<template>
  <div class="about">
    <input v-focus/>
  </div>
</template>
<script>
  export default {
    name:'About',
    directives:{
      focus:{
        inserted:function (el) {
          el.focus()
        }
      }
    }
  }
</script>
```



**全局注册**

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```



### 过滤器:常见的文本格式化

```html
{{message | capitalize}}
或
<div v-bind:id='rawId | formatId'></div>
```

**本地过滤器**

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```



**全局过滤器**

```js
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```





### keep-alive

vue内置组件，保证失活的组件保留状态而不会重新渲染。

```html
<keep-alive include=‘a,b’>
		<component></component>
</keep-alive>
```

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- `max` - 数字。最多可以缓存多少组件实例。



### 修饰符

在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。

1. .stop

   ```html
   <!-- 阻止单击事件继续传播 -->
   <a v-on:click.stop="doThis"></a>
   ```

2. .prevent

3. .capture

   ```html
   <!-- 添加事件监听器时使用事件捕获模式 -->
   <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
   <div v-on:click.capture="doThis">...</div>
   ```

4. .self

```html
<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```

5. .once

6. .passive  不要和.prevent一起用。.prevent会被忽略。**能提升移动端性能**

```html
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```



## react

### 父子组件生命周期流程

1. 首次渲染

   **父组件的渲染会触发子组件渲染，所有子组件挂载后才会触发父组件挂载**

2.  setState回调和componentDidUpdate执行顺序？

   先执行componentDidUpdate，再执行setState回调。

## 模块化

### commonjs

1. commonjs在模块中形成自身作用域。对外不可见。

2. 导出：module.exports.

   ```js
   const module={
     exports:{},
   }
   const exports =module.exports
   ```

   1. 不能给exports直接赋值。否则会覆盖。

   2. ```js
      exports.add =()=>{}
      module.exports ={}
      // 下面会将上面覆盖
      ```

3. 导入

   1. 导出的module对象会有一个loaded来记录该模块是否被加载过。
   2. 第一次require 会先执行导入模块。然后导出内容。
   3. 第二次则不执行，直接返回结果。



### es6 module

1. 导出

   ```js
   // 方式1 a.js
   export const name 
   export const add =()=>{}
   export default  Button;
   
   // 方式2
   export {name, add}
   
   // 方式3
   // export default 对外输出了一个名为default的变量。
   export default {
     name: 'abc',
     add:()=>{}
   }
   ```

2. 导入：

   ```js
   // 方式1
   import * as cal from './a.js'
   cal.name
   cal.add
   
   import Button,{name} from './a.js'
   
   
   // 方式2
   import { name, add} from './a.js'
   
   // 方式3，自由指定名字。
   import my from './a.js'
   my.add
   ```

   

### COMMONJS 和ES6 区别

#### 动态与静态

1. commonjs 是动态的：模块依赖发生在运行时。
   1. 优点是可以放在代码的任何位置。甚至可以再if中判断是否引入该模块
   2. 本质上导入一个对象
2. es6是静态的： 模块依赖发生在编译阶段。
   1. **死代码检测和排除。减小打包体积**。
   2. 既可以导入变量。也可以导入的对象。减小引用层级。



#### 值拷贝和动态映射

1. commonjs中类似于

   ```js
   a =3; // 类似于要导出的模块
   b=a; // 导入
   b //b可以任意操作，但是改变不了a的值
   ```

2. es6中无法直接修改导出模块的值。但是可以通过调用模块内部的方法修改。



#### 循环依赖的问题

commonjs无解

es6某些情况下可以支持。



## webpack

见xmind笔记

![webpack面试](https://tva1.sinaimg.cn/large/008i3skNly1gs4n15wkenj60u01s47wh02.jpg)





## HTTP缓存

### Last-Modified && Expires && 相对时间Cache-Control

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsl43wjbupj30p80sa0uv.jpg" alt="image-20210718150053179" style="zoom:50%;" />



###  Etag && If-None-Match



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsl44dl9z1j30sc0uqju6.jpg" alt="image-20210718150123936" style="zoom:50%;" />



### Cache-Control属性

1. `public`表明其他用户也可以使用缓存。

2. `private`缓存服务器只缓存特定用户的缓存。
3. `no-cache`: **从服务器的角度上：不缓存过期资源，缓存服务器需要向源服务器确认有效期才可以缓存。**
   1. 如果客户端携带该首部：客户端不会接受缓存过的响应，每次请求缓存服务器都会把请求发给请求服务器。服务端要是携带这个字段，那么缓存服务器可以缓存，但是要确认。
   2. `no-cache=Location`服务器返回给客户端的响应中出现该字段，那么这之后的就不能再缓存了，上面的无属性值的还可以缓存。
4. `no-store`：**不缓存**





1. `s-maxage=604800`:多用户的共同缓存有效期

2. `max-age`
3. `min-fresh=60`：缓存资源超过60秒就不要了。
4. `max-stale(不新鲜)`只要max-stale设置了 或者max-stale设置了属性值，那么就不会过期。
5. `only-if-cached`:缓存服务器不要重新请求响应，只从缓存中取数据，如果取不到就返回504
6. `no-transform`:无论请求还是响应中，缓存都不能改变实体的内容。**可以防止压缩**











# 常见综合面试题

### 从输入URL到页面加载发生了什么？

1. DNS解析
   1. 解析过程.-->.com-->google.com.-->www.google.com
   2. DNS优化
      1. DNS缓存：浏览器缓存、系统缓存、路由器缓存等
      2. DNS负载均衡:CDN

2. TCP连接
   1. 三次握手
3. 发送http请求
4. 服务器处理请求返回报文
5. 浏览器解析渲染界面
   1. 解析HTML，生成DOM
   2. 解析CSS，生成CSSOM
   3. 合并DOM/CSSOM，生成render
   4. 回流和重绘
6. 断开连接
   1. 四次挥手













# 计算机网络

## 网络分层

### 五层和ISO七层

| 层名       | 常见协议                         | 备注 |
| ---------- | -------------------------------- | ---- |
| 应用层     | HTTP、SMTP（电子邮件）、FTP、DNS |      |
| 传输层     | TCP、UDP                         |      |
| 网络层     | IP、ICMP、ARP                    |      |
| 数据链路层 |                                  |      |
| 物理层     |                                  |      |



## HTTP

**HTTP（超文本传输协议）报文包括：通用头部、请求/响应头部、请求/响应体**。

### 状态码

| 分类 | 描述                               | 常用                                                     |
| ---- | ---------------------------------- | -------------------------------------------------------- |
| 1xx  | 指示信息，表示请求已经接收继续处理 |                                                          |
| 2xx  | 成功                               | 200：OK                                                  |
|      |                                    | 204：成功，但没资源返回                                  |
| 3xx  | 重定向                             | 301：永久重定向                                          |
|      |                                    | 302：临时重定向，资源被临时移动，客户端应继续使用原有URI |
|      |                                    | 304：重定向到缓存                                        |
| 4xx  | 客户端错误                         | 404                                                      |
| 5xx  | 服务器错误                         | 500                                                      |

### HTTP和HTTPS区别

1. HTTP明文，HTTPS是ssl加密传输协议，CA证书
2. HTTP80端口，HTTPS443端口





### HTTP1.1

相较于HTTP1.0：

1. 引入更多的缓存处理：Entity tag，If-Unmodified-Since, If-Match, If-None-Match等
2. 部分请求，range
3. 错误通知，加入错误响应码
4. 添加HOST头，HTTP1.0中，认为一个服务器绑定一个IP所以没有hostname，但是后来出现的虚拟主机共享一个IP地址。

### HTTP2.0

![HTTP2.0 &&1.1](https://tva1.sinaimg.cn/large/008i3skNly1gs65wlodu5j31nx0u0dnz.jpg)

#### HTTP1.1存在的问题

1. 线头阻塞：一个TCP连接只能发送一个请求，前面的请求未完成后面的需要排队。
2. 并发，HTTP1.1的并发依赖多个TCP连接，连接成本高。且管线化的方案浏览器较难实现。
3. 头部冗余
   1. 头部采用纯文本格式
   2. 每一个请求都携带cookie，user-agent等完全相同的头部 
4. 客户端需要主动请求



#### stream、message、Frame

* 流：HTTP1.X一个TCP连接建立一个流，HTTP2.0可以有多个流
* 消息：一个流可以包含多个消息，包括多个帧
* 帧：通信的基本单位。



#### HTTP2.0

#####  二进制分帧层

**核心是采用二进制而不是1.x的文本格式传输数据**

一条HTTP消息分为以下两个帧：

* HEADERS首部
* DATA消息负载



##### 多路复用

HTTP2建立一个TCP连接，一个连接上有任意多个流，消息分割成一个或者多个帧在流中传输。帧传输完成后再进行组装。形成一个完整的请求或响应。





##### 头部压缩

在浏览器和服务器端维护一个静态和动态字典。减少传输头部长度





##### 服务器端推送

> 客户端请求index.html，服务器端能够额外推送script.js和style.css。 实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源





<img src="https://tva1.sinaimg.cn/large/008i3skNly1gs66t4oyw2j30ts0ssjtm.jpg" alt="image-20210705171055461" style="zoom:67%;" />









### url和uri

URL和URN是URI的子集，URI属于URL更高层次的抽象

![image-20201109220005877](https://tva1.sinaimg.cn/large/0081Kckwgy1gkj9oru558j30cy06ct9i.jpg)



## TCP问题

[三次握手和四次挥手](https://segmentfault.com/a/1190000020610336)

#### 三次握手

1. SYN 同步标识 =1，seq序列号为x
2. ACK=1，ack=x+1  (对收到同步标识和序列号确认)  SYN=1  seq=y  (自身信息)
3. 对2中自身信息确认：ACK=1,ack=y+1。seq=x+1（自身信息）





<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjpql5s42kj311u0p0n7l.jpg" alt="image-20201015085751146" style="zoom:50%;" />

##### 为什么不是二次握手?

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。



##### 三次握手可以携带数据么？

第一次握手不可以携带数据。否则第一次携带大量信息会导致攻击。第三次可以携带。



##### SYN攻击是什么？

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。





#### 四次挥手

FIN报文表示在该方向上不会发送报文了。

![image-20201015092052749](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjpr91ugesj31860nkwqe.jpg)



##### 为什么挥手需要四次?

> 服务端确认客户端FIN报文 和服务端等待关闭的报文可能不是一起的。

但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。



##### 为什么等待2MSL（最长报文段寿命）

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。





## 加密

### 对称加密

常见的对称加密：DES、AES

### 非对称加密

RSA

### MD5





# 安全

## XSS（跨站脚本攻击）

> 恶意攻击者往Web页面里插入恶意javaScript代码，当用户浏览该页之时，嵌入其中Web里面的javaScript代码会被执行，从而达到恶意攻击用户的目的。

分为以下两种类型：

### 反射类型

例如通过url直接注入。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grxmtmdzbxj30l204kq4q.jpg" alt="image-20210628073451703" style="zoom:67%;" />



### 存储型

> 通过写入数据库的方式，在用户读取数据库时被执行。



### 注入方式：

1. HTML节点插入script
2. HTML属性插入，如img
3. js代码中
4. 富文本



### 防御方式

1. chrome自带防御可以防御上面1.2两种方式
2. 自己转义，主要通过对于输入、引号进行转义。
3. 对于富文本，可以采用
   1. 黑名单，把危险方式一律禁止。较为困难
   2. 白名单 ，采用cheerio库，只允许部分标签和属性
4. **CSP内容安全策略 **





## CSRF(跨站请求伪造)

攻击流程：

- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。



### 特点

1. CSRF通常发生在第三方域名
2. CSRF攻击者只能使用cookie，但是不能获取cookie等信息。



### 防御

1. 阻止不明外域的访问
   1. **同源检测** 相对简单的实现方案
      1. Origin Header
      2. Referer Header
   2. Samesite Cookie
2. 提交时需要携带本域才能获取的信息
   1. CSRF Token
   2. 双重cookie验证
3. 验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。
4. SameSite Cookie





#### Origin Header

> 如果存在可以用来确认同源

有两种情况可能不存在：

* IE11同源策略
* 302重定向的时候可能没有Origin中。



#### SameSite Cookie

1. Samesite = Strick

假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。

1. Samesite = Lax







# 操作系统

## 进程与线程

进程通过PCB（Process Control Block）进程控制块描述进程信息和运行状态。对于进程的创建和撤销都是对于PCB的操作。

**进程是资源分配的基本单位，线程是独立调度的基本单位。**

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。



## 进程状态切换



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grxq5ea3ijj30gm0630uc.jpg" alt="image-20210628093000719" style="zoom:100%;" />



## 进程调度算法

* 批处理系统

  * 先来先服务（FCFS）
  * 短作业优先（SJF shortest job first）
  * 最短剩余时间优先（SRTN）

* 交互式系统

  * 时间片轮转

  * 优先级调度： 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

  * **多级反馈队列**

    一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

    多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

    每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

    可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

![img](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)

## 进程同步

1. 临界区
2. 同步与互斥
3. 信号量：Semaphore，只能PV操作。



## 进程通讯

1. 管道pipe
   1. 缺点：
      1. 只能半双工
      2. 只能在父子、兄弟进程中使用
2. FIFO 命名管道，**去除了管道只能在父子进程中使用的限制**
3. 消息队列
4. 信号量
5. 共享存储
6. 套接字socket







# 重要的面试题目

## promise

[掘金45题](https://juejin.cn/post/6844904077537574919#heading-2)

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    setTimeout(() => {
        console.log("timerStart");
        resolve("success");
        console.log("timerEnd");
    }, 0);
    console.log(2);
});
promise.then((res) => {
    console.log(res);
});
console.log(4);
```



```js
setTimeout(() => {
    console.log('timer1');
    Promise.resolve().then(() => {
        console.log('promise')
    })
}, 0)
setTimeout(() => {
    console.log('timer2')
}, 0)
console.log('start')

```

```js
//微任务中有宏任务,会被加入到全局的宏任务队列中
Promise.resolve().then(() => {
    console.log('promise1');
    const timer2 = setTimeout(() => {
        console.log('timer2')
    }, 0)
});
const timer1 = setTimeout(() => {
    console.log('timer1')
    Promise.resolve().then(() => {
        console.log('promise2')
    })
}, 0)
console.log('start');
```







# 后端

## node

* [参考掘金博客](https://juejin.cn/post/6844903908385488903#heading-11)
* 深入浅出node.js

### node多进程

通过以下创建：

1. child_process
2. cluster



<img src="https://tva1.sinaimg.cn/large/008i3skNly1gsaflnqrqej30ng0iktch.jpg" alt="image-20210709091721185" style="zoom:50%;" />







### node多线程

通过worker_threads创建。

## KOA

### 洋葱模型

```js
const Koa = require('koa');

const app = new Koa();
const PORT = 3000;

// #1
app.use(async (ctx, next)=>{
    console.log(1)
    await next();
    console.log(1)
});
// #2
app.use(async (ctx, next) => {
    console.log(2)
    await next();
    console.log(2)
})

app.use(async (ctx, next) => {
    console.log(3)
})

app.listen(PORT);
console.log(`http://localhost:${PORT}`);
```







# 设计模式

## 发布订阅

```js
class EventEmitter {
    constructor() {
        this.eventpool ={};
    }

    on(event,callback){
        if (this.eventpool[event]){
            this.eventpool[event].push(callback);
        }else {
            this.eventpool[event] =[callback];
        }
    }
    off(event){
        delete this.eventpool[event]
    }

  //	on实现，对于callback进行一次封装。
    once(event,callback){
        this.on(event,()=>{
            callback();
            this.off(event);
        })
    }

    emit(event,...args){
        if (this.eventpool[event]){
            this.eventpool[event].forEach(item=>{
                item(...args);
            })
        }
    }
}
```





# 字节面试

![image-20210709151804913](https://tva1.sinaimg.cn/large/008i3skNgy1gsaq11dyj5j316e0i677k.jpg)



1. 判断数组
2. 

```js
window.name = 'ByteDance';

function Foo (name) {
  this.name = name || 'bar';
}

Foo.prototype.getName = function(){
  console.log(this);
  return this.name + 1;
}

let foo = new Foo();
let getName = foo.getName;

console.log(getName());   //window B1
console.log(foo.getName()); // Foo bar1
console.log(getName.call(Foo)) // Foo Foo1


const foo2 = new Foo('xxx');

foo2.name ? xxx
Foo.name ? bar
```





3. 

```js
构造函数A
 - 函数签名：const a = new A(name);
 - 实例属性name  // 字符串
 - 原型对象属性有一个run方法
   - function () { 
      console.log(`${this.name} run`); 
    }

构造函数B
 - 函数签名：const b = new B(name, email);
 - 实例对象拥有A的所有实例属性
 - 实例对象自定义一个email属性  // 字符串
 - 原型对象继承于A
 - 原型对象上自定义一个swim方法
   - function () { 
       console.log(`${this.name} swim, email: ${this.email}`); 
   }
```



4. 

```js
5. 给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。

示例:

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]
解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```





